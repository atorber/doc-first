// 全新的模块化文档结构模板
module.exports = {
  'README.md': `# 文档库说明

本文档库遵循“文档即代码”（Docs as Code）和“Vibe Coding”的最佳实践，旨在为人类和AI提供清晰、精确、可扩展的上下文。

## 目录结构理念

- **全局文档**: 定义了整个项目的通用规范、架构和上下文。这是所有模块共享的“宪法”。
- **模块文档**: 每个子目录代表一个独立的功能模块或服务。这里是模块的“执行细则”。

这种混合结构实现了“高内聚、低耦合”的文档管理，能精准地为AI提供其所需上下文，从而实现高效开发。
`,

  // 0. 参考资料
  '0_参考资料/README.md': `# 参考资料

本目录存放项目相关的参考资料。

## 外部文档
- API 文档
- 技术选型对比
- 学习资源

## 使用方法
将相关的外部文档保存在此目录，便于团队成员查阅。
`,

  // 1. 全局文档
  '1_全局文档/1_项目总览.md': `# 1. 项目总览

## 1.1 项目愿景与使命

[简要描述项目要解决的核心问题、目标用户和最终愿景。]

## 1.2 核心目标与成功指标

- **目标1**: [例如：在6个月内，将用户注册转化率提高20%。]
  - **指标 (KRs)**:
    - KR1: [可量化的关键结果]
    - KR2: [可量化的关键结果]

## 1.3 通用术语表

| 术语 | 定义 |
| --- | --- |
| | |
| | |
`,
  '1_全局文档/2_总体技术架构.md': `# 2. 总体技术架构

## 2.1 架构图

[使用 Mermaid 或其他图表工具，绘制项目的高层架构图，展示模块间的关系。]

\`\`\`mermaid
graph TD
    A[用户] --> B{API网关};
    B --> C[模块A服务];
    B --> D[模块B服务];
    C --> E[数据库];
    D --> E;
\`\`\`

## 2.2 技术栈选型

| 领域 | 技术 | 备注 |
| --- | --- | --- |
| 前端 | | |
| 后端 | | |
| 数据库 | | |
| 缓存 | | |
| CI/CD | | |

## 2.3 跨模块设计原则

- **通信协议**: [例如：所有内部服务间通信使用 gRPC。]
- **数据一致性**: [例如：关键业务采用分布式事务，非关键业务采用最终一致性。]
- **错误处理**: [定义统一的错误码和返回格式。]
`,
  '1_全局文档/3_通用开发规范.md': `# 3. 通用开发规范

## 3.1 Git工作流

[描述团队采用的 Git 分支模型，例如 GitFlow 或 Trunk-Based Development。]

## 3.2 编码风格

- **语言**: [链接到相应的代码风格指南，如 ESLint, Prettier 配置。]
- **命名约定**: 
- **注释规范**:

## 3.3 代码审查 (Code Review)

- **审查流程**:
- **审查要点**:

## 3.4 CI/CD 流程

[简述 CI/CD 的主要阶段和工具。]
`,

  '1_全局文档/4_测试规范与模板.md': `# 4. 测试规范与模板

## 4.1 测试策略

### 测试金字塔
- **单元测试**: 覆盖率目标 80%
- **集成测试**: 覆盖率目标 60%
- **端到端测试**: 核心流程覆盖

## 4.2 测试模板

### 单元测试模板
\`\`\`javascript
describe('[功能模块]', () => {
  it('应该实现 [预期行为]', () => {
    // Arrange
    // Act
    // Assert
  });
});
\`\`\`

### 集成测试模板
\`\`\`javascript
describe('API: [接口名称]', () => {
  it('应该返回正确的数据', async () => {
    const response = await request(app)
      .post('/api/endpoint')
      .send({ /* 测试数据 */ });
    expect(response.status).toBe(200);
  });
});
\`\`\`

## 4.3 测试覆盖率要求

- 新增代码必须包含测试
- 覆盖率不低于 80%
- 核心业务逻辑必须 100% 覆盖

## 4.4 测试工具

| 类型 | 工具 |
| --- | --- |
| 单元测试 | Jest / Vitest / pytest |
| 集成测试 | Supertest / pytest |
| E2E 测试 | Playwright / Cypress |
`,

  '1_全局文档/5_代码审查指南.md': `# 5. 代码审查指南

## 5.1 审查流程

1. **创建 PR**: 开发者完成功能后创建 Pull Request
2. **自动检查**: CI 自动运行测试和 Lint
3. **Code Review**: 至少一名团队成员审查
4. **合并**: 审查通过后合并到主分支

## 5.2 审查要点

### 功能性
- [ ] 功能按需求实现
- [ ] 边界条件处理正确
- [ ] 错误处理完善

### 代码质量
- [ ] 符合编码规范
- [ ] 无重复代码
- [ ] 变量命名清晰
- [ ] 适当的注释

### 测试
- [ ] 有单元测试
- [ ] 有集成测试（如稀缺）
- [ ] 所有测试通过
- [ ] 测试覆盖率达标

### 性能
- [ ] 无明显的性能问题
- [ ] 数据库查询优化

### 安全性
- [ ] 无安全漏洞
- [ ] 敏感信息未泄露

## 5.3 审查意见处理

### 必须修改
- 功能性缺陷
- 安全漏洞
- 严重的性能问题

### 建议修改
- 代码风格问题
- 命名优化
- 添加注释

### 可选优化
- 性能微调
- 代码重构
`,

  '1_全局文档/6_全局AI上下文.md': `# 6. 全局AI上下文

本文件为AI提供整个项目范围内的通用上下文。

## 6.1 通用领域知识

- **核心业务规则**:
  - [规则1]
  - [规则2]
- **关键业务实体**:
  - [实体1: 描述]
  - [实体2: 描述]

## 6.2 AI-人类协作流程

### 6.2.1 何时该介入？
在以下情况需要人工介入：
- 🚨 核心业务逻辑的实现
- 🔒 安全相关的代码变更
- 🏗️ 架构层面的重大调整
- 📊 性能关键路径的修改

### 6.2.2 如何给反馈？
使用标准反馈格式：

\`\`\`
**评估结果**: ✅ 通过 / ⚠️ 需要修改 / ❌ 不通过

**具体意见**:
- [具体问题1]
- [具体问题2]

**修改建议**:
- [建议1]
- [建议2]
\`\`\`

### 6.2.3 反馈的标准格式
- **明确**: 具体指出问题所在
- **建设性**: 提供修改建议
- **优先级**: 区分"必须修改"和"建议优化"

## 6.3 全局提示词库 (Prompt Library)

### 代码生成

- **场景**: 创建一个新的 React 组件
- **Prompt**:
  \`\`\`
  请为一个名为 [组件名] 的 React 组件生成代码。它应该接收以下 props: ...，并遵循我们的编码规范。
  \`\`\`

### 测试生成

- **场景**: 为一个函数生成单元测试
- **Prompt**:
  \`\`\`
  请为以下函数生成单元测试用例，使用 [测试框架]，确保测试覆盖所有分支。
  [粘贴函数代码]
  \`\`\`

### 系统级调试

- **场景**: 定位系统级问题
- **Prompt**:
  \`\`\`
  系统出现问题：[问题描述]
  当前表现：[系统行为]
  可能原因：[你的初步分析]
  请帮我分析根本原因并提供修复方案。
  \`\`\`
`,

  // 2. 模块文档
  '2_模块文档/README.md': `# 模块文档说明

本目录存放所有功能模块的详细文档。每个模块都是一个独立的子目录。

## 如何创建新模块？

1. 在本目录下创建一个新的子目录，以模块名命名（例如 \`用户模块/\`）。
2. 在新目录中，复制以下模板文件并进行填充：
   - \`1_需求规格.md\` - 功能需求和用户故事
   - \`2_技术设计.md\` - 技术选型和架构设计
   - \`3_API接口文档.md\` - API 接口定义
   - \`4_数据库设计.md\` - 数据库设计和 ER 图
   - \`5_测试用例.md\` - 测试计划和测试用例
   - \`6_部署配置.md\` - 环境配置和部署步骤
   - \`7_模块AI上下文.md\` - 模块专属 AI 上下文
   - \`8_AI交互记录.md\` - 记录与AI的协作过程（新增）

## 模块文档结构

每个模块应该包含完整的文档，从需求到部署，形成闭环。
`,
  '2_模块文档/模块A/README.md': `# 模块A

## 模块简介

[简要描述“模块A”的功能和职责。]

## 负责人

- @[你的名字]
`,
  '2_模块文档/模块A/1_需求规格.md': `# 1. 需求规格 (模块A)

## 1.1 用户故事

- 作为 [角色], 我希望 [功能], 以便 [价值]。

## 1.2 功能列表

- **功能1**:
  - 描述:
  - 验收标准:
    - [ ] 标准1
`,
  '2_模块文档/模块A/2_技术设计.md': `# 2. 技术设计 (模块A)

## 2.1 模块内部架构

[使用 Mermaid 绘制模块内部的组件图或流程图。]

## 2.2 技术选型

| 组件 | 技术选型 | 说明 |
| --- | --- | --- |
| 框架 | | |
| 数据库 | | |
| 缓存 | | |

## 2.3 设计原则

- **单一职责**: 
- **依赖注入**: 
- **接口抽象**:
`,

  '2_模块文档/模块A/3_API接口文档.md': `# 3. API接口文档 (模块A)

## 3.1 接口列表

### 接口1: [接口名称]

**请求**
\`\`\`
POST /api/v1/endpoint
Content-Type: application/json

{
  "param1": "value1",
  "param2": "value2"
}
\`\`\`

**响应**
\`\`\`json
{
  "code": 200,
  "message": "success",
  "data": {
    "id": "string",
    "name": "string"
  }
}
\`\`\`

**错误码**
| 错误码 | 说明 |
| --- | --- |
| 400 | 参数错误 |
| 404 | 资源不存在 |

## 3.2 接口依赖

- 依赖其他模块: [模块名]
- 调用第三方API: [API名称]
`,

  '2_模块文档/模块A/4_数据库设计.md': `# 4. 数据库设计 (模块A)

## 4.1 ER 图

\`\`\`mermaid
erDiagram
    User ||--o{ Order : places
    Order ||--|{ OrderItem : contains
    
    User {
        string id PK
        string username
        string email
    }
    
    Order {
        string id PK
        string user_id FK
        datetime created_at
    }
\`\`\`

## 4.2 表结构

### users 表

| 字段名 | 类型 | 约束 | 说明 |
| --- | --- | --- | --- |
| id | VARCHAR(36) | PK | 用户ID |
| username | VARCHAR(50) | UNIQUE | 用户名 |
| email | VARCHAR(100) | UNIQUE | 邮箱 |
| created_at | TIMESTAMP | NOT NULL | 创建时间 |

### 索引

- idx_username ON users(username)
- idx_email ON users(email)

## 4.3 数据迁移

- 版本: v1.0
- 迁移脚本: [链接]
`,

  '2_模块文档/模块A/5_测试用例.md': `# 5. 测试用例 (模块A)

## 功能1

| # | 测试步骤 | 预期结果 |
|---|---|---|
| 1 | | |
`,

  '2_模块文档/模块A/6_部署配置.md': `# 6. 部署配置 (模块A)

## 6.1 环境变量

| 变量名 | 说明 | 默认值 |
| --- | --- | --- |
| PORT | 服务端口 | 3000 |
| DATABASE_URL | 数据库连接 | |
| REDIS_URL | Redis连接 | |

## 6.2 Docker 配置

\`\`\`dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
\`\`\`

## 6.3 部署步骤

1. 构建镜像: \`docker build -t module-a .\`
2. 运行容器: \`docker run -p 3000:3000 module-a\`
3. 健康检查: \`curl http://localhost:3000/health\`

## 6.4 依赖服务

- 数据库服务
- Redis 服务
- 其他模块服务
`,

  '2_模块文档/模块A/7_模块AI上下文.md': `# 7. 模块AI上下文 (模块A)

## 7.1 模块专属领域知识

- **规则1**: [仅适用于本模块的业务规则]

## 7.2 模块专属提示词

- **场景**: [例如：为模块A的某个服务生成一个方法]
- **Prompt**:
  \`\`\`
  [针对模块A高度优化的Prompt]
  \`\`\`

## 7.3 与全局上下文的配合

在使用本模块的AI上下文时，请同时参考全局文档中的：
- \`../1_全局文档/6_全局AI上下文.md\` - 全局领域知识
- \`../1_全局文档/2_总体技术架构.md\` - 技术架构约束
- \`../1_全局文档/3_通用开发规范.md\` - 编码规范
`,

  '2_模块文档/模块A/8_AI交互记录.md': `# 8. AI交互记录 (模块A)

本文档记录与AI的交互过程，遵循ICCM（迭代式对话协作）模式。

## 使用说明

每次与AI协作开发功能时，在本文档中记录完整的交互过程，包括：
- 需求描述
- AI的初始理解
- 人工审查结果
- 迭代修改
- 最终采用方案

---

## 交互记录模板

### 任务1: [功能名称]

**日期**: [YYYY-MM-DD]

**需求描述**:
\`\`\`
[简要描述需要实现的功能]
\`\`\`

**AI Prompt**:
\`\`\`
[你对AI发出的提示词]
\`\`\`

**AI初步响应**:
\`\`\`
[AI返回的内容摘要]
\`\`\`

**人工审查**:
- ✅ 通过
- ⚠️ 需要修改
- ❌ 不通过

**审查意见**:
- [具体问题1]
- [具体问题2]

**修改Prompt**:
\`\`\`
[如有修改，记录新的提示词]
\`\`\`

**AI二次响应**:
\`\`\`
[如果有多次迭代，记录后续响应]
\`\`\`

**最终采用方案**:
\`\`\`
[记录最终采用的代码或方案]
\`\`\`

**总结**:
- ✅ 成功经验
- ⚠️ 需要注意的问题
- 📝 改进建议

---

*使用说明：每次新的功能开发时，复制上面的模板并填写*
`,

  // 3. 部署运维
  '3_部署运维/README.md': `# 部署运维文档

本目录存放项目部署和运维相关文档。

## 文档结构

- 部署指南
- 环境配置
- CI/CD 配置
- 监控告警
- 日志管理
- 故障排查
`,

  '3_部署运维/1_部署指南.md': `# 1. 部署指南

## 1.1 部署环境

| 环境 | 地址 | 用途 |
| --- | --- | --- |
| 开发环境 | dev.example.com | 本地开发测试 |
| 测试环境 | test.example.com | QA 测试 |
| 预发布环境 | staging.example.com | 发布前验证 |
| 生产环境 | prod.example.com | 线上服务 |

## 1.2 部署流程

### 开发环境
\`\`\`bash
# 1. 检出代码
git clone https://github.com/your-org/your-repo.git
cd your-repo

# 2. 安装依赖
npm install

# 3. 配置环境变量
cp .env.example .env

# 4. 启动服务
npm run dev
\`\`\`

### 生产环境
\`\`\`bash
# 使用 Docker 部署
docker-compose up -d

# 或使用 Kubernetes
kubectl apply -f k8s/
\`\`\`

## 1.3 回滚策略

- 保留最近 3 个版本
- 回滚命令: \`kubectl rollout undo deployment/app-name\`
`,

  '3_部署运维/2_环境配置.md': `# 2. 环境配置

## 2.1 必需的环境变量

\`\`\`bash
# 数据库配置
DATABASE_URL=postgresql://user:pass@localhost:5432/dbname

# Redis 配置
REDIS_URL=redis://localhost:6379

# JWT 密钥
JWT_SECRET=your-secret-key

# 日志级别
LOG_LEVEL=info
\`\`\`

## 2.2 各环境配置差异

| 配置项 | 开发 | 测试 | 生产 |
| --- | --- | --- | --- |
| DEBUG | true | false | false |
| LOG_LEVEL | debug | info | warn |
| DATABASE | 本地 | 测试库 | 生产库 |
`,

  '3_部署运维/3_CI-CD配置.md': `# 3. CI/CD 配置

## 3.1 CI 流程

### GitHub Actions 示例
\`\`\`yaml
name: CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run tests
        run: npm test
      - name: Build
        run: npm run build
\`\`\`

## 3.2 CD 流程

1. **自动构建**: Push 到 main 分支触发
2. **运行测试**: 自动化测试套件
3. **构建镜像**: Docker 镜像构建
4. **部署**: 自动部署到测试环境
5. **手动审批**: 生产环境需要手动审批
`,

  '3_部署运维/4_监控告警.md': `# 4. 监控告警

## 4.1 监控指标

### 系统指标
- CPU 使用率
- 内存使用率
- 磁盘 I/O
- 网络流量

### 应用指标
- 请求量 (QPS)
- 响应时间 (P95, P99)
- 错误率
- 成功率

## 4.2 告警规则

| 指标 | 阈值 | 级别 |
| --- | --- | --- |
| CPU 使用率 | > 80% | 警告 |
| CPU 使用率 | > 90% | 紧急 |
| 内存使用率 | > 85% | 警告 |
| 错误率 | > 5% | 紧急 |
| 响应时间 | > 1s | 警告 |

## 4.3 告警处理

1. **接收到告警**: 查看告警详情
2. **定位问题**: 查看日志和监控面板
3. **处理问题**: 执行故障排查
4. **修复问题**: 部署修复代码
5. **记录总结**: 更新故障排查文档
`,

  '3_部署运维/5_日志管理.md': `# 5. 日志管理

## 5.1 日志级别

- **DEBUG**: 详细调试信息
- **INFO**: 一般信息
- **WARN**: 警告信息
- **ERROR**: 错误信息

## 5.2 日志存储

- **本地日志**: \`logs/app.log\`
- **集中存储**: ELK Stack / Loki
- **保留期限**: 30 天

## 5.3 日志查询

\`\`\`bash
# 查看最新日志
tail -f logs/app.log

# 搜索错误日志
grep ERROR logs/app.log

# 使用 ELK 查询
# 在 Kibana 中查询日志
\`\`\`
`,

  '3_部署运维/6_故障排查.md': `# 6. 故障排查与系统级调试

## 6.1 系统级调试方法论

### 6.1.1 系统级调试的核心理念

在Vibe Coding中，开发者不再逐行调试代码，而是：
1. **从系统行为出发** - 观察整体表现而非局部
2. **引导AI修复** - 将问题描述清晰传达给AI
3. **系统验证** - 通过测试验证修复效果

### 6.1.2 系统级诊断流程

#### 第一步：症状观察
\`\`\`
**问题症状**: 
- [具体的错误表现]
- [发生的时间和环境]
- [影响范围]
\`\`\`

#### 第二步：系统行为分析
\`\`\`
**系统行为**: 
- [正常运行时的行为]
- [故障时的行为]
- [行为差异分析]
\`\`\`

#### 第三步：根本原因推测
\`\`\`
**可能原因**:
1. [原因1 - 可能性评估]
2. [原因2 - 可能性评估]
3. [原因3 - 可能性评估]

**优先级**: [最可能的原因]
\`\`\`

#### 第四步：AI引导修复
将上述信息清晰地传达给AI：
\`\`\`
系统出现问题：[问题描述]
当前表现：[系统行为]
可能原因：[你的初步分析]
请帮我分析根本原因并提供修复方案。
\`\`\`

### 6.1.3 系统级调试检查清单

- [ ] 已收集完整的错误日志
- [ ] 已观察系统整体行为
- [ ] 已分析可能的原因
- [ ] 已向AI清晰描述问题
- [ ] 已对AI提供的方案进行审查
- [ ] 已通过测试验证修复

## 6.2 常见问题

### 服务无法启动

**症状**: 服务启动后立即退出

**排查步骤**:
1. 检查端口是否被占用
2. 检查环境变量是否正确
3. 查看启动日志

**解决方案**:
\`\`\`bash
# 检查端口
lsof -i :3000

# 检查环境变量
env | grep DATABASE
\`\`\`

### 数据库连接失败

**症状**: 应用无法连接数据库

**排查步骤**:
1. 检查数据库服务状态
2. 验证连接字符串
3. 检查网络连通性

**解决方案**:
\`\`\`bash
# 测试数据库连接
psql -h host -U user -d dbname

# 检查网络
nc -zv hostname 5432
\`\`\`

## 6.2 应急响应

### P0 - 紧急故障
- 响应时间: 15 分钟
- 处理流程: 立即定位、快速修复、事后复盘

### P1 - 高优先级
- 响应时间: 1 小时
- 处理流程: 评估影响、制定方案、执行修复

## 6.3 故障报告模板

\`\`\`
故障时间: 
影响范围: 
症状描述: 
根本原因: 
处理过程: 
预防措施: 
\`\`\`
`
};



